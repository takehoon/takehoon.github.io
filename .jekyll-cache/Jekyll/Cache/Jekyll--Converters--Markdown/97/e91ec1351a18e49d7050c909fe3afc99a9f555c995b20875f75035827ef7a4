I"L0<h1 id="javascript-기초-빠르게-찍어먹기-3---함수">Javascript 기초 빠르게 찍어먹기 3 - (함수)</h1>

<h2 id="31-개요">3.1 개요</h2>
<p>이전 <a href="https://takehoon.github.io/javascript/2021/05/10/javascript기초빠르게찍어먹기2.html">Javascript 기초 빠르게 찍어먹기 2</a> 에서 객체에 대해 살펴보았습니다. 이번 포스트에서는 Javascript 의 함수에 대해 알아보겠습니다.</p>

<p>우리는 필요한 데이터를 메모리상에 저장해두고 그 위치를 변수로 기억을 하며 변수를 통해 데이터에 접근합니다. 반면 필요한 데이터가 여러 개라면 어떻게 할까요? 우리는 이를 <strong><em>함수</em></strong> 로 정의하여 사용합니다. 즉, 함수를 메모리상에 저장해두고 필요할때마다 이를 꺼내서 사용합니다.</p>

<h3 id="311-함수">3.1.1 함수</h3>
<p>Javascript는 이러한 함수를 <strong><em>function</em></strong> keyword를 이용하여 정의합니다.</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">method</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">code</span>
<span class="p">}</span>
</code></pre></div></div>
<p>또한 javascript에서는 익명 함수라는 것이 존재합니다. 이름 그대로 함수명이 없는 함수로써 다음과 같이 정의합니다.</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">method</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="nx">code</span>
<span class="p">}</span>
</code></pre></div></div>

<p>함수의 정의 자체는 바로 실행되지 않습니다. 다만 함수를 호출할 때에 정의한 내용을 기억해두었다가 실행합니다.</p>

<h3 id="312-호이스팅hoisting">3.1.2 호이스팅(Hoisting)</h3>
<p>익명 함수 얘기가 나왔으니 <strong><em>호이스팅(hoisting)</em></strong>에 대한 설명이 필요할 것 같습니다. 호이스팅은 쉽게 말해 <em>정의를 찾는다</em> 라고 볼 수 있습니다.</p>

<p>위에 언급한 예제들을 이용하여 설명드리자면, <code class="language-plaintext highlighter-rouge">function method()</code> 보다 <code class="language-plaintext highlighter-rouge">method()</code>코드가 먼저 나온다하더라도 문제없이 실행됩니다. 그 이유는 호이스팅에 의해 정의를 찾아 <em>끌어올려</em> 함수 실행에 문제가 없도록 합니다.</p>

<p>하지만, 익명 함수를 사용하면서 <code class="language-plaintext highlighter-rouge">method = function()</code>보다 <code class="language-plaintext highlighter-rouge">method()</code> 코드를 먼저 실행할 경우에는 호이스팅을 지원하지 않아 함수가 실행되지 않아 에러를 발생시킵니다.</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">func1</span><span class="p">()</span> <span class="c1">// 함수 정의보다 먼저 나오더라도 hoisting에 의해 정상 실행</span>

<span class="kd">function</span> <span class="nx">func1</span><span class="p">()</span> <span class="p">{</span>
    <span class="nb">document</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="dl">"</span><span class="s2">hoisting</span><span class="dl">"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">func2</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="nb">document</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="dl">"</span><span class="s2">hoisting x</span><span class="dl">"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">func2</span><span class="p">()</span> <span class="c1">// 익명 함수로 hoisting을 지원하지 않아 함수 정의가 먼저 나온뒤 호출되어야 한다.</span>
</code></pre></div></div>

<h2 id="32-parameter">3.2 parameter</h2>
<p>javascript의 함수도 parameter를 가질 수 있습니다. parameter를 가진 함수의 기본형은 다음과 같습니다.</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">method</span><span class="p">(</span><span class="nx">param1</span><span class="p">,</span> <span class="nx">param2</span><span class="p">,</span> <span class="nx">param3</span><span class="p">,</span> <span class="p">...,</span> <span class="nx">paramN</span><span class="p">){</span>
    <span class="nx">code</span>
<span class="p">}</span>
</code></pre></div></div>

<p>물론 parameter의 개수를 가변적으로 받을 수 있는 방법도 지원합니다. 이때 <strong><em>arguments</em></strong> 변수를 이용합니다. <code class="language-plaintext highlighter-rouge">arguments</code>변수는 배열처럼 접근하여 사용하면 됩니다.</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">method</span><span class="p">(){</span>
    <span class="k">for</span><span class="p">(</span><span class="nx">i</span> <span class="k">in</span> <span class="nx">arguments</span><span class="p">){</span>
        <span class="nx">documents</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="nx">arguments</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="33-함수-scope">3.3 함수 scope</h2>
<p>scope는 변수 또는 함수의 유효 범위를 말합니다.</p>

<h3 id="331-local-변수--global-변수">3.3.1 local 변수 &amp; global 변수</h3>
<p>전역 변수(global)는 어디에서나 사용할 수 있는 변수를 말하며, 지역 변수(local)는 해당 함수 scope에서만 사용할 수 있는 변수입니다.</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">val</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">global</span><span class="dl">"</span>

<span class="kd">function</span> <span class="nx">method</span><span class="p">(){</span>
    <span class="kd">var</span> <span class="nx">val</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">local</span><span class="dl">"</span>

    <span class="nx">alert</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span> <span class="c1">// "local"</span>
<span class="p">}</span>

<span class="nx">alert</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span> <span class="c1">// "global"</span>
</code></pre></div></div>
<p>위의 예제와 같이 함수 내에서 정의한 변수는 해당 함수에서만 유효하고 이 블록을 벗어나게 되면 더이상 유효하지 않게됩니다. 반면 전역 변수는 지역 변수와 동일한 명칭을 사용하지 않는다면 어디에서나 사용이 가능합니다.</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">val</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">global</span><span class="dl">"</span>

<span class="kd">function</span> <span class="nx">method</span><span class="p">(){</span>
    <span class="nx">alert</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span> <span class="c1">// "global"</span>
<span class="p">}</span>

<span class="nx">alert</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span> <span class="c1">// "global"</span>
</code></pre></div></div>

<h3 id="332-global-함수와-local-함수의-차이">3.3.2 global 함수와 local 함수의 차이</h3>
<p>전역 함수(global)와 지역 함수(local)도 변수와 동일합니다.</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nb">global</span><span class="p">(){</span>
    <span class="nx">code</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">method</span><span class="p">(){</span>
    <span class="kd">function</span> <span class="nx">local</span><span class="p">(){</span>
        <span class="nx">code</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>위 예제에서 <code class="language-plaintext highlighter-rouge">global()</code> 함수는 어디에서나 사용이 가능하지만, <code class="language-plaintext highlighter-rouge">local()</code>함수는 ```method()`` 함수 내에서만 사용이 가능합니다.</p>

<h3 id="333-즉시-실행-함수">3.3.3 즉시 실행 함수</h3>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">val</span> <span class="o">=</span> <span class="mi">100</span>
<span class="kd">function</span> <span class="nx">method</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">val</span> <span class="o">+=</span> <span class="mi">100</span>
    <span class="nx">alert</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span> <span class="c1">// 200</span>
<span class="p">}</span>
<span class="nx">method</span><span class="p">()</span>
<span class="kd">function</span> <span class="nx">method</span><span class="p">(){</span>
    <span class="nx">alert</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span> <span class="c1">// 100</span>
<span class="p">}</span>
</code></pre></div></div>
<p>위의 예제는 결국 100을 alert합니다. 그 이유는 마지막에 정의한 <code class="language-plaintext highlighter-rouge">method()</code> 함수가 호이스팅되어 호출되기 때문입니다.</p>

<p>이와 같이 지역 함수의 명칭이 충돌하여 원치않는 결과를 출력할 수도 있습니다. 이를 해결하기 위해서 <em>즉시 실행 함수</em>에 대해서 살펴보도록 하겠습니다. 우선 즉시 실행 함수로 위 문제를 해결해보겠습니다.</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
    <span class="kd">var</span> <span class="nx">val</span> <span class="o">=</span> <span class="mi">100</span>
    <span class="kd">function</span> <span class="nx">method</span><span class="p">(){</span>
        <span class="nx">val</span> <span class="o">+=</span> <span class="mi">100</span><span class="p">;</span>
        <span class="nx">alert</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span> <span class="c1">// 200</span>
    <span class="p">}</span>
    <span class="nx">method</span><span class="p">()</span> 
<span class="p">}());</span>
<span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
    <span class="kd">var</span> <span class="nx">val</span> <span class="o">=</span> <span class="mi">100</span>
    <span class="kd">function</span> <span class="nx">method</span><span class="p">(){</span>
        <span class="nx">alert</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span> <span class="c1">// 100</span>
    <span class="p">}</span>
<span class="p">}());</span>
</code></pre></div></div>
<p>즉, <code class="language-plaintext highlighter-rouge">function</code> keyword를 이용하여 함수 scope 를 별도로 생성하고 이 안에서 <code class="language-plaintext highlighter-rouge">method()</code>함수를 정의함으로써 동일한 이름을 가진 함수지만 다른 함수 scope로 인해 원하는 결과인 200 을 출력할 수 있게 됩니다.</p>

<h2 id="34-객체-생성자-함수의-활용">3.4 객체 생성자 함수의 활용</h2>
<h3 id="341-객체-생성자-함수">3.4.1 객체 생성자 함수</h3>

:ET